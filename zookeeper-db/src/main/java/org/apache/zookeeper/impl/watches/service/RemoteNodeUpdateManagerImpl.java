package org.apache.zookeeper.impl.watches.service;

import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.impl.common.NamedThreadFactory;
import org.apache.zookeeper.impl.node.bean.NodeUpdate;
import org.apache.zookeeper.impl.watches.dao.NodeUpdateDao;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Simple implementation of RemotedNodeUpdate.
 * <p>
 * Every new local WatchedEvent is stored in the database.
 * WatchedEvents generated by remote brokers are pulled from the database every half a second.
 */
public class RemoteNodeUpdateManagerImpl extends RemoteNodeUpdateManager {

	private static Logger logger = LoggerFactory.getLogger(RemoteNodeUpdateManagerImpl.class);

	private NodeUpdateDao nodeUpdateDao;
	private int broker;
	private int lastPulledId;
	private boolean lastIdChecked;
	private ScheduledExecutorService cleanerService;
	private ScheduledExecutorService updatesPullService;

	public RemoteNodeUpdateManagerImpl(NodeUpdateDao nodeUpdateDao) {
		this.nodeUpdateDao = nodeUpdateDao;
		this.broker = 100 + (int) (Math.random() * 100);
		this.lastPulledId = -1;

		cleanerService = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory("Updates-cleaner"));
		cleanerService.scheduleWithFixedDelay(new Runnable() {
			@Override
			public void run() {
				clearUpdates();
			}
		}, 1, 1, TimeUnit.MINUTES);

		updatesPullService = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory("Pull-updates"));
		updatesPullService.scheduleWithFixedDelay(new Runnable() {
			@Override
			public void run() {
				pullUpdates();
			}
		}, 5, 500, TimeUnit.MILLISECONDS);
	}

	private void pullUpdates() {
		try {
			if (!lastIdChecked) {
				lastPulledId = getLasttId();
				lastIdChecked = true;
			}

			List<NodeUpdate> updates = nodeUpdateDao.getNodeUpdates(broker, lastPulledId);
			if (!updates.isEmpty()) {
				lastPulledId = updates.get(updates.size() - 1).getId();
			}

			for (NodeUpdate update : updates) {
				logger.info("Processing update " + update);
				WatchedEvent event = new WatchedEvent(update.getEventType(), Watcher.Event.KeeperState.SyncConnected, update.getPath());
				processRemoteWatchedEvent(event);
			}
		} catch (Exception e) {
			logger.warn("pull updates failed [" + e.getMessage() + "]");
		}
	}

	private void clearUpdates() {
		try {
			nodeUpdateDao.clearProcessedUpdates(broker, lastPulledId);
			nodeUpdateDao.clearOldUpdates(System.currentTimeMillis() - 10 * 60 * 1000);
		} catch (Exception e) {
			logger.warn("clear updates failed [" + e.getMessage() + "]");
		}
	}

	private int getLasttId() {
		return nodeUpdateDao.getLastUpdateId();
	}

	@Override
	public void processLocalWatchedEvent(WatchedEvent event) {
		try {
			NodeUpdate update = new NodeUpdate(event.getType(), event.getPath(), System.currentTimeMillis());
			nodeUpdateDao.insertUpdate(broker, update);
		} catch (Exception e) {
			logger.warn("clear updates failed [" + e.getMessage() + "]");
		}
	}
}
